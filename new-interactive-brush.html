<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>PostgreSQL Performance Farm Results Reporter</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />

    <link
      rel="shortcut icon"
      href="https://avatars.githubusercontent.com/u/37238056?s=200&v=4"
      type="image/x-icon"
    />

    <style>
      body {
        background-color: #fcfcfc;
        box-sizing: border-box;
      }
      .axis path,
      .axis line {
        stroke: #333;
        stroke-width: 0.8;
      }
      .axis text {
        fill: #4b5563;
        font-size: 12px;
      }
      .grid path {
        display: none;
      }
      .grid line {
        stroke: #e2e8f0;
      }

      .brush .selection {
        fill: rgba(50, 102, 144, 0.645);
        stroke: #336690;
        stroke-width: 1px;
      }

      .tooltip {
        position: absolute;
        opacity: 0;
        visibility: hidden;
        background: rgba(0, 0, 0, 0.85);
        color: white;
        padding: 8px 12px;
        border-radius: 6px;
        font-size: 12px;
        line-height: 1.5;
        white-space: nowrap;
        transition: opacity 0.2s;
        z-index: 1000;
        pointer-events: auto;
      }

      .tooltip.show {
        opacity: 1;
        visibility: visible;
      }

      .tooltip .tooltip-date {
        font-size: 11px;
        color: #c1c1c1;
        margin-bottom: 8px;
        padding-bottom: 6px;
        border-bottom: 1px solid #555;
      }
      .tooltip strong {
        font-weight: 500;
        color: #ddd;
        display: inline-block;
        min-width: 60px;
      }
      .tooltip .version-item {
        display: flex;
        align-items: center;
        margin-bottom: 4px;
      }
      .tooltip .version-color {
        width: 10px;
        height: 10px;
        border-radius: 50%;
        margin-right: 8px;
        flex-shrink: 0;
      }
      .tooltip .version-name {
        flex-grow: 1;
        margin-right: 10px;
        font-weight: 400;
      }

      .tooltip .version-value {
        font-weight: 700;
        font-size: 14px;
        text-align: right;
        color: #ffffff;
      }

      .tooltip .commit-details {
        margin-top: 10px;
        padding-top: 8px;
        border-top: 1px solid #555;
      }
      .tooltip a {
        color: #6bb2ff;
        text-decoration: none;
        font-weight: 500;
      }
      .tooltip a:hover {
        text-decoration: underline;
      }

      /* --- ARROW STYLES --- */
      .tooltip::after {
        content: '';
        position: absolute;
        border-width: 7px;
        border-style: solid;
        border-color: transparent;
      }
      .arrow-up::after {
        bottom: 100%;
        left: 50%;
        transform: translateX(-50%);
        border-bottom-color: rgba(0, 0, 0, 0.85);
      }
      .arrow-down::after {
        top: 100%;
        left: 50%;
        transform: translateX(-50%);
        border-top-color: rgba(0, 0, 0, 0.85);
      }
      .arrow-left::after {
        right: 100%;
        top: 50%;
        transform: translateY(-50%);
        border-right-color: rgba(0, 0, 0, 0.85);
      }
      .arrow-right::after {
        left: 100%;
        top: 50%;
        transform: translateY(-50%);
        border-left-color: rgba(0, 0, 0, 0.85);
      }

      .form-label {
        display: block;
        font-size: 14px;
        font-weight: 500;
        color: #1f2937;
        margin-bottom: 8px;
      }
      .form-select,
      #branch-select-button {
        appearance: none;
        -webkit-appearance: none;
        -moz-appearance: none;
        padding: 10px 40px 10px 12px;
        font-size: 14px;
        color: #374151;
        border: 1px solid #d1d5db;
        border-radius: 6px;
        background-color: white;
        background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 20 20' fill='currentColor'%3E%3Cpath fill-rule='evenodd' d='M5.22 8.22a.75.75 0 0 1 1.06 0L10 11.94l3.72-3.72a.75.75 0 1 1 1.06 1.06l-4.25 4.25a.75.75 0 0 1-1.06 0L5.22 9.28a.75.75 0 0 1 0-1.06Z' clip-rule='evenodd' /%3E%3C/svg%3E");
        background-repeat: no-repeat;
        background-position: right 12px center;
        background-size: 1.25rem;
        width: 100%;
        cursor: pointer;
        outline: none;
        height: 42px;
        text-align: left;
      }
      .form-select option {
        direction: rtl;
      }
      .form-select:focus,
      #branch-select-button:focus {
        border-color: #336791;
        box-shadow: 0 0 0 1px #336791;
      }

      #branch-filter-dropdown {
        display: none;
        position: absolute;
        background-color: white;
        border: 1px solid #d1d5db;
        border-radius: 0.375rem;
        box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1),
          0 2px 4px -2px rgba(0, 0, 0, 0.1);
        z-index: 10;
        margin-top: 0.25rem;
        width: 100%;
        padding: 0.5rem;
      }
      .branch-filter-actions {
        display: flex;
        justify-content: space-between;
        padding: 0.5rem;
        border-bottom: 1px solid #e5e7eb;
      }
      .branch-filter-actions button {
        font-size: 0.75rem;
        color: #336791;
        font-weight: 500;
        background: none;
        border: none;
        padding: 0.25rem;
        cursor: pointer;
      }
      #branch-list-container {
        max-height: 200px;
        overflow-y: auto;
        padding: 0.5rem;
      }
      #branch-list-container label {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        font-weight: 400;
        font-size: 0.875rem;
        margin-bottom: 0.5rem;
        cursor: pointer;
        color: #374151;
      }

      /* Y-Axis Toggle Styles */
      .y-axis-toggle-fieldset {
        padding: 0;
        border: none;
      }
      .y-axis-toggle-container {
        display: flex;
        border: 1px solid #d1d5db;
        border-radius: 6px;
        overflow: hidden;
        height: 100%;
        width: 180px;
      }
      .y-axis-toggle-container input {
        display: none;
      }
      .y-axis-toggle-container label {
        flex: 1;
        padding: 8px 8px;
        font-size: 14px;
        text-align: center;
        cursor: pointer;
        color: #374151;
        background-color: white;
        transition: background-color 0.2s, color 0.2s;
        user-select: none;
      }
      .y-axis-toggle-container label:not(:last-child) {
        border-right: 1px solid #d1d5db;
      }
      .y-axis-toggle-container input:checked + label {
        background-color: #336791;
        color: white;
        font-weight: 500;
      }
      .y-axis-toggle-container:has(:focus-visible) {
        border-color: #336791;
        box-shadow: 0 0 0 1px #336791;
      }

      .legend-container {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        gap: 0.5rem 1.5rem;
        margin-top: 1.5rem;
        padding: 1rem;
      }
      .legend-item {
        display: flex;
        align-items: center;
        cursor: pointer;
        font-size: 0.8rem;
        color: #374151;
        transition: opacity 0.2s;
      }
      .legend-item.inactive {
        opacity: 0.4;
      }
      .legend-item svg {
        width: 24px;
        height: 24px;
        margin-right: 0.25rem;
      }
    </style>
  </head>
  <body class="p-4">
    <main>
      <header class="flex justify-between items-start mb-6 pb-4">
        <div>
          <h1 class="text-2xl font-semibold text-gray-800">
            DBT2 Test Results on Fireweed
          </h1>
        </div>
        <div>
          <p
            id="lastUpdated"
            class="text-sm text-[#336790] font-medium text-right"
          ></p>
        </div>
      </header>

      <section
        class="grid grid-cols-1 md:grid-cols-3 gap-8 mb-8 mt-4 max-w-4xl"
      >
        <div class="filter-group">
          <label for="chooseScale" class="form-label">Scale Factor</label>
          <select
            id="chooseScale"
            name="chooseScale"
            class="form-select"
          ></select>
        </div>
        <div class="filter-group relative">
          <label for="branch-select-button" class="form-label"
            >Choose Branches</label
          >
          <button id="branch-select-button">Select Branches</button>
          <div id="branch-filter-dropdown">
            <div class="branch-filter-actions">
              <button id="branch-select-all">Select All</button>
              <button id="branch-deselect-all">Deselect All</button>
            </div>
            <div id="branch-list-container"></div>
          </div>
        </div>
        <!-- Creating a div for filter mode of view of y-axis -->
        <div>
          <label class="form-label">Y-Axis Mode</label>

          <fieldset class="y-axis-toggle-fieldset">
            <div class="y-axis-toggle-container">
              <input
                type="radio"
                id="mode-zero"
                name="y_axis_mode"
                value="zero"
                checked
              />
              <label for="mode-zero">From 0</label>

              <input
                type="radio"
                id="mode-zoom"
                name="y_axis_mode"
                value="zoom"
              />
              <label for="mode-zoom">Zoomed</label>
            </div>
          </fieldset>
        </div>
      </section>

      <svg id="chart-svg" width="100%" class="bg-gray-100"></svg>
      <div id="legend-container" class="legend-container"></div>
      <footer class="mt-10 pt-6 border-t border-gray-200">
        <h3 class="text-base font-semibold text-gray-800 mb-3">
          Chart Controls
        </h3>
        <ul class="list-disc list-inside text-sm text-gray-700 space-y-3">
          <li>
            <strong class="font-semibold text-gray-800">Zoom:</strong> To
            inspect a specific time range, use one of two methods:
            <ul class="list-['–'] list-inside mt-2 ml-6 space-y-1">
              <li>
                Click and drag horizontally across the
                <span class="font-medium">lower context chart</span>.
              </li>
              <li>
                Click and drag horizontally directly on the
                <span class="font-medium">main chart</span>.
              </li>
            </ul>
          </li>
          <li>
            <strong class="font-semibold text-gray-800">Inspect Data:</strong>
            Hover over any data point on the main chart to view detailed
            information for that specific test run.
          </li>
          <li>
            <strong class="font-semibold text-gray-800">Pan:</strong> Once
            zoomed in, pan the view left or right using the
            <kbd
              class="px-1.5 py-0.5 text-xs font-semibold text-gray-800 bg-gray-100 border border-gray-200 rounded"
              >Arrow Keys</kbd
            >.
          </li>
          <li>
            <strong class="font-semibold text-gray-800">Reset View:</strong> To
            return to the full time range, double-click anywhere on the main
            chart or press the
            <kbd
              class="px-1.5 py-0.5 text-xs font-semibold text-gray-800 bg-gray-100 border border-gray-200 rounded"
              >Esc</kbd
            >
            key.
          </li>
        </ul>
      </footer>
      <div class="tooltip"></div>
    </main>

    <script>
      let allData = [];
      let scaleDataCounts = new Map();
      const currentFilters = { scale: null, branches: [] };
      const DOMElements = {};
      const BRANCH_ICON_SVG = `<svg viewBox="0 0 256 256" xmlns="http://www.w3.org/2000/svg"><rect fill="none" height="256" width="256"/><path d="M248,120H187.5a60,60,0,0,0-118.9,0H8a8,8,0,0,0,0,16H68.6a60,60,0,0,0,118.9,0H248a8,8,0,0,0,0-16Z"/></svg>`;
      let xScale, yScale, xAxis, yAxis, line, xGrid, yGrid;
      let currentChartData = [];

      // Application entry point
      document.addEventListener('DOMContentLoaded', () => {
        // Cache DOM references for efficient future use
        cacheDOMElements();

        // Fetch the CSV data (static resource assumed to be served from ./fireweed.csv)
        fetch('./fireweed.csv')
          .then((response) => response.text()) // Convert the response into plain text
          .then((csvText) => {
            allData = parseCSV(csvText).map((d) => ({
              branch: d.branch || 'unknown',
              revision: d.revision,
              scale: +d.scale,
              ctime: new Date(d.ctime * 1000),
              metric: +d.metric,
              commit_message: d.commit_message || `Commit: ${d.revision}`,
            }));
            const counts = d3.rollup(
              allData,
              (v) => v.length,
              (d) => d.scale
            );
            scaleDataCounts = new Map(counts);
            initializeApp(allData);
          })
          .catch(handleError);
      });

      function initializeApp(data) {
        setupFilterControls(data);
        setupEventListeners();
        applyFiltersAndRender();
        updateLastUpdated(data);
      }

      function cacheDOMElements() {
        Object.assign(DOMElements, {
          svg: d3.select('#chart-svg'),
          tooltip: d3.select('.tooltip'),
          scaleFilter: document.getElementById('chooseScale'),
          legendContainer: d3.select('#legend-container'),
          lastUpdated: document.getElementById('lastUpdated'),
          branchSelectButton: document.getElementById('branch-select-button'),
          branchFilterDropdown: document.getElementById(
            'branch-filter-dropdown'
          ),
          branchListContainer: document.getElementById('branch-list-container'),
          branchSelectAll: document.getElementById('branch-select-all'),
          branchDeselectAll: document.getElementById('branch-deselect-all'),
          modeZero: document.getElementById('mode-zero'),
          modeZoom: document.getElementById('mode-zoom'),
        });
      }

      function setupFilterControls(data) {
        // Get unique scale values, sorted numerically
        const uniqueScales = [...scaleDataCounts.keys()].sort((a, b) => a - b);

        // Clear any existing options in the options filters dropdown
        DOMElements.scaleFilter.innerHTML = '';

        // Populate the dropdown with new scale options
        uniqueScales.forEach((scale) => {
          const option = document.createElement('option'); // Create new option element
          option.value = scale; // Set the value of the option to the scale
          const count = scaleDataCounts.get(scale); // Get the count of results for this scale
          option.textContent = `${scale} (${count} results)`; // Set the visible text of the option
          DOMElements.scaleFilter.appendChild(option); //Add the option to the dropdown
        });

        // Set the current selected scale to the first available one, or null if none
        currentFilters.scale = uniqueScales[0] || null;

        // Reflect the selected scale in the dropdown UI
        DOMElements.scaleFilter.value = currentFilters.scale;

        // Update related filters (e.g., branches) based on the selected scale
        updateBranchFilter();
      }

      function updateYAxis(data, duration = 250) {
        if (!data || data.length === 0 || !yScale) return;

        const yAxisMode = document.querySelector(
          'input[name="y_axis_mode"]:checked'
        ).value;
        const { svg } = DOMElements;

        const [xMin, xMax] = xScale.domain();
        const visibleData = data.filter(
          (d) => d.ctime >= xMin && d.ctime <= xMax
        );

        if (yAxisMode === 'zoom' && visibleData.length > 0) {
          const yMin = d3.min(visibleData, (d) => d.metric);
          const yMax = d3.max(visibleData, (d) => d.metric);
          yScale.domain([yMin * 0.95, yMax * 1.05]);
        } else {
          const yMax = d3.max(data, (d) => d.metric);
          yScale.domain([0, yMax * 1.05]);
        }

        const t = svg.transition().duration(duration);
        svg.select('.axis.y-axis-group').transition(t).call(yAxis);
        svg.select('.grid.y-grid').transition(t).call(yGrid.scale(yScale));
        svg
          .selectAll('.line')
          .transition(t)
          .attr('d', ([, v]) => line(v));
        svg
          .selectAll('.data-circle')
          .transition(t)
          .attr('cx', (d) => xScale(d.ctime))
          .attr('cy', (d) => yScale(d.metric));
      }

      function setupEventListeners() {
        DOMElements.scaleFilter.addEventListener('change', (e) => {
          currentFilters.scale = +e.target.value;
          updateBranchFilter(true);
          applyFiltersAndRender();
        });

        document
          .querySelectorAll('input[name="y_axis_mode"]')
          .forEach((radio) => {
            radio.addEventListener('change', () => {
              updateYAxis(currentChartData);
            });
          });

        DOMElements.branchSelectButton.addEventListener('click', () => {
          const isHidden =
            DOMElements.branchFilterDropdown.style.display === 'none' ||
            !DOMElements.branchFilterDropdown.style.display;
          DOMElements.branchFilterDropdown.style.display = isHidden
            ? 'block'
            : 'none';
        });

        document.addEventListener('click', (e) => {
          if (
            !DOMElements.branchSelectButton.contains(e.target) &&
            !DOMElements.branchFilterDropdown.contains(e.target)
          ) {
            DOMElements.branchFilterDropdown.style.display = 'none';
          }
        });

        DOMElements.branchListContainer.addEventListener('change', (e) => {
          if (e.target.type === 'checkbox') {
            currentFilters.branches = Array.from(
              DOMElements.branchListContainer.querySelectorAll('input:checked')
            ).map((cb) => cb.value);
            updateBranchButtonText();
            applyFiltersAndRender();
          }
        });

        DOMElements.branchSelectAll.addEventListener('click', () =>
          toggleAllBranches(true)
        );
        DOMElements.branchDeselectAll.addEventListener('click', () =>
          toggleAllBranches(false)
        );
      }

      function checkBounds(
        left,
        top,
        tooltipWidth,
        tooltipHeight,
        containerWidth,
        containerHeight
      ) {
        return (
          top >= 0 &&
          left >= 0 &&
          left + tooltipWidth <= containerWidth &&
          top + tooltipHeight <= containerHeight
        );
      }

      function applyFiltersAndRender() {
        const dataForScale = allData.filter(
          (d) => d.scale === currentFilters.scale
        );
        const allBranchesForScale = [
          ...new Set(dataForScale.map((d) => d.branch)),
        ]
          .sort()
          .reverse();
        console.log('All branches for scale (ordered):', allBranchesForScale);
        const colorScale = d3
          .scaleOrdinal(d3.schemeTableau10)
          .domain(allBranchesForScale);

        console.log('ColorScale domain set to:', colorScale.domain());
        const filteredData = dataForScale.filter((d) =>
          currentFilters.branches.includes(d.branch)
        );
        renderChart(filteredData, colorScale);
        renderLegend(allBranchesForScale, colorScale);
      }

      function updateBranchFilter(reset = true) {
        const availableBranches = [
          ...new Set(
            allData
              .filter((d) => d.scale === currentFilters.scale)
              .map((d) => d.branch)
          ),
        ]
          .sort()
          .reverse();
        if (reset) {
          currentFilters.branches = [...availableBranches];
        }
        DOMElements.branchListContainer.innerHTML = '';
        availableBranches.forEach((branch) => {
          const id = `branch-cb-${branch.replace(/\W/g, '-')}`;
          const isChecked = currentFilters.branches.includes(branch);
          const label = document.createElement('label');
          label.setAttribute('for', id);
          label.innerHTML = `<input type="checkbox" id="${id}" value="${branch}" ${
            isChecked ? 'checked' : ''
          }><span>${branch}</span>`;
          DOMElements.branchListContainer.appendChild(label);
        });
        updateBranchButtonText();
      }

      function updateBranchButtonText() {
        const count = currentFilters.branches.length;
        const total =
          DOMElements.branchListContainer.querySelectorAll('input').length;
        DOMElements.branchSelectButton.textContent =
          count === total
            ? 'All Branches Selected'
            : count === 0
            ? 'No Branches Selected'
            : `${count} Branches Selected`;
      }

      function toggleAllBranches(select) {
        const checkboxes =
          DOMElements.branchListContainer.querySelectorAll('input');
        checkboxes.forEach((cb) => (cb.checked = select));
        currentFilters.branches = select
          ? Array.from(checkboxes).map((cb) => cb.value)
          : [];
        updateBranchButtonText();
        applyFiltersAndRender();
      }

      function renderChart(data, colorScale) {
        currentChartData = data;
        const { svg } = DOMElements;
        svg.selectAll('*').remove();
        if (data.length === 0) {
          svg
            .append('text')
            .attr('x', '50%')
            .attr('y', '50%')
            .attr('text-anchor', 'middle')
            .text('No data for selected filters.')
            .style('fill', '#6b7280');
          return;
        }

        const mainChartHeight = 400;
        const contextChartHeight = 80;
        const spacing = 60;
        svg.attr('height', mainChartHeight + spacing + contextChartHeight);

        const width = svg.node().getBoundingClientRect().width;
        const margin = { top: 20, right: 30, bottom: 40, left: 60 };
        const chartWidth = width - margin.left - margin.right;
        const chartHeight = mainChartHeight - margin.top - margin.bottom;

        const xInitialDomain = d3.extent(data, (d) => d.ctime);
        const yInitialDomain = [0, d3.max(data, (d) => d.metric) * 1.05];

        xScale = d3.scaleTime().domain(xInitialDomain).range([0, chartWidth]);
        yScale = d3
          .scaleLinear()
          .domain(yInitialDomain)
          .range([chartHeight, 0]);

        const yAxisMode = document.querySelector(
          'input[name="y_axis_mode"]:checked'
        ).value;
        if (yAxisMode === 'zoom') {
          const yMin = d3.min(data, (d) => d.metric);
          yScale.domain([yMin * 0.95, d3.max(data, (d) => d.metric) * 1.05]);
        }

        const chart = svg
          .append('g')
          .attr('transform', `translate(${margin.left}, ${margin.top})`);
        svg
          .append('defs')
          .append('clipPath')
          .attr('id', 'chart-clip')
          .append('rect')
          .attr('width', chartWidth)
          .attr('height', chartHeight);

        xAxis = d3
          .axisBottom(xScale)
          .ticks(5)
          .tickFormat(d3.timeFormat('%b %d, %Y'));
        yAxis = d3.axisLeft(yScale).ticks(8);
        xGrid = d3
          .axisBottom(xScale)
          .ticks(5)
          .tickSize(-chartHeight)
          .tickFormat('');
        yGrid = d3.axisLeft(yScale).tickSize(-chartWidth).tickFormat('');

        chart
          .append('g')
          .attr('class', 'grid x-grid')
          .attr('transform', `translate(0, ${chartHeight})`)
          .call(xGrid);
        chart.append('g').attr('class', 'grid y-grid').call(yGrid);
        const xAxisGroup = chart
          .append('g')
          .attr('class', 'axis x-axis-group')
          .attr('transform', `translate(0, ${chartHeight})`)
          .call(xAxis);
        const yAxisGroup = chart
          .append('g')
          .attr('class', 'axis y-axis-group')
          .call(yAxis);

        const clipArea = chart
          .append('g')
          .attr('clip-path', 'url(#chart-clip)');

        // X-Axis Label
        // chart
        //   .append('text')
        //   .attr('class', 'axis-label x-label')
        //   .attr('text-anchor', 'middle')
        //   .attr('x', chartWidth / 2) // Center the label horizontally.
        //   .attr('y', chartHeight + margin.bottom - 5) // Position it below the x-axis within the margin area.
        //   .style('fill', '#333')
        //   .text('Commit Date');

        // // Y-Axis Label
        // chart
        //   .append('text')
        //   .attr('class', 'axis-label y-label')
        //   .attr('transform', 'rotate(-90)') // Rotate the label for the Y-axis.
        //   .attr('text-anchor', 'middle')
        //   .attr('y', 0 - margin.left + 20) // Position it to the left of the y-axis.
        //   .attr('x', 0 - chartHeight / 2) // Center it vertically along the chart height.
        //   .style('fill', '#333')
        //   .text('Metric Value');

        line = d3
          .line()
          .x((d) => xScale(d.ctime))
          .y((d) => yScale(d.metric));
        const groupedData = d3.group(data, (d) => d.branch);

        clipArea
          .selectAll('.line')
          .data(groupedData)
          .join('path')
          .attr('class', 'line')
          .attr('fill', 'none')
          .attr('stroke', ([branch]) => colorScale(branch))
          .attr('stroke-width', 2)
          .attr('d', ([, v]) => line(v.sort((a, b) => a.ctime - b.ctime)));

        // chart
        //   .selectAll('.line')
        //   .data(groupedData)
        //   .join('path')
        //   .attr('class', 'line')
        //   .attr('fill', 'none')
        //   .attr('stroke', ([branch]) => colorScale(branch))
        //   .attr('stroke-width', 1.5)
        //   .attr('d', ([, v]) => line(v.sort((a, b) => a.ctime - b.ctime)));

        const contextTopPosition = mainChartHeight + margin.top;
        const contextGroup = svg
          .append('g')
          .attr('class', 'context')
          .attr(
            'transform',
            `translate(${margin.left}, ${contextTopPosition})`
          );
        const xScale2 = d3
          .scaleTime()
          .domain(xInitialDomain)
          .range([0, chartWidth]);
        const yContextDomain = [0, d3.max(data, (d) => d.metric) * 1.05];
        const yScale2 = d3
          .scaleLinear()
          .domain(yContextDomain)
          .range([contextChartHeight, 0]);

        const contextLine = d3
          .line()
          .x((d) => xScale2(d.ctime))
          .y((d) => yScale2(d.metric));

        contextGroup
          .selectAll('.context-line')
          .data(groupedData)
          .join('path')
          .attr('fill', 'none')
          .attr('stroke', ([b]) => colorScale(b))
          .attr('stroke-opacity', 0.7)
          .attr('stroke-width', 1)
          .attr('d', ([, v]) =>
            contextLine(v.sort((a, b) => a.ctime - b.ctime))
          );
        contextGroup
          .append('g')
          .attr('transform', `translate(0, ${contextChartHeight})`)
          .call(
            d3
              .axisBottom(xScale2)
              .ticks(width / 100)
              .tickFormat(d3.timeFormat('%b %Y'))
          );

        // --- START OF UPDATED BRUSH LOGIC ---

        // Brush for the context chart (bottom navigator)
        const contextBrush = d3
          .brushX()
          .extent([
            [0, 0],
            [chartWidth, contextChartHeight],
          ])
          .on('end', brushedContext);

        const contextBrushGroup = contextGroup
          .append('g')
          .attr('class', 'brush context-brush')
          .call(contextBrush);

        // Brush for the X-Axis of the main chart

        const xAxisBrush = d3
          .brushX()
          .extent([
            [0, 0],
            [chartWidth, chartHeight],
          ])
          .on('end', brushedXAxis);

        const branchCircles = clipArea
          .selectAll('.data-circle')
          .data(data)
          .join('circle')
          .attr('class', 'data-circle')
          .attr('cx', (d) => xScale(d.ctime))
          .attr('cy', (d) => yScale(d.metric))
          .attr('r', 4)
          .attr('fill', (d) => colorScale(d.branch))
          .attr('stroke', 'white')
          .attr('stroke-width', 1);

        // const branchCircles = chart
        //   .selectAll('.data-circle')
        //   .data(data)
        //   .join('circle')
        //   .attr('class', 'data-circle')
        //   .attr('cx', (d) => xScale(d.ctime))
        //   .attr('cy', (d) => yScale(d.metric))
        //   .attr('r', 3.5)
        //   .attr('fill', (d) => colorScale(d.branch))
        //   .attr('stroke', 'white')
        //   .attr('stroke-width', 1);

        const xAxisBrushGroup = clipArea
          .append('g')
          .attr('class', 'brush xaxis-brush')
          .call(xAxisBrush);

        // Add capturing mousedown listener to the main group
        clipArea.on('mousedown.brush-reorder', function (event) {
          // Move brush to front when mousedown occurs
          xAxisBrushGroup.raise();
        });

        // Add brushend event to move brush back
        xAxisBrush.on('end.reorder', function (event) {
          // Move brush back under dots after brushing
          setTimeout(() => {
            branchCircles.raise();
          }, 50);
        });

        // Ensure circles are initially on top
        branchCircles.raise();

        setupTooltip(branchCircles, colorScale, xScale, yScale, margin);

        chart.on('dblclick', resetZoom);
        svg
          .on('mouseover', () =>
            window.addEventListener('keydown', handleKeyDown)
          )
          .on('mouseout', () =>
            window.removeEventListener('keydown', handleKeyDown)
          );

        function redrawChart(duration = 500) {
          const t = svg.transition().duration(duration).ease(d3.easeCubicInOut);
          xAxisGroup.transition(t).call(xAxis.scale(xScale));
          chart.select('.x-grid').transition(t).call(xGrid.scale(xScale));
          updateYAxis(currentChartData, duration);
        }

        // Handler for the new X-Axis brush
        function brushedXAxis(event) {
          if (event.selection) {
            const [x0, x1] = event.selection.map(xScale.invert);
            xScale.domain([x0, x1]);
            xAxisBrushGroup.call(xAxisBrush.move, null);
            contextBrushGroup.call(
              contextBrush.move,
              xScale.domain().map(xScale2)
            );
            redrawChart();
          }
        }

        // Handler for the context (bottom) brush
        function brushedContext(event) {
          if (event.selection) {
            const [x0, x1] = event.selection.map(xScale2.invert);
            xScale.domain([x0, x1]);
            redrawChart();
            xAxisBrushGroup.call(xAxisBrush.move, null);
          }
        }

        function resetZoom() {
          xScale.domain(xInitialDomain);
          contextBrushGroup.call(contextBrush.move, null);
          xAxisBrushGroup.call(xAxisBrush.move, null);
          redrawChart();
        }

        const handleKeyDown = (event) => {
          if (event.key === 'Escape') {
            resetZoom();
            return;
          }
          if (['ArrowLeft', 'ArrowRight'].includes(event.key)) {
            event.preventDefault();
            const percentage = event.key === 'ArrowLeft' ? -0.1 : 0.1;
            const [x0, x1] = xScale.domain();
            const shift = (x1 - x0) * percentage;
            xScale.domain([
              new Date(x0.getTime() + shift),
              new Date(x1.getTime() + shift),
            ]);
            contextBrushGroup.call(
              contextBrush.move,
              xScale.domain().map(xScale2)
            );
            xAxisBrushGroup.call(xAxisBrush.move, null);
            redrawChart(100);
          }
        };
      }

      // function setupTooltip(circles, colorScale, xScale, yScale, margin) {
      //   const tooltip = DOMElements.tooltip;

      //   const container = d3.select('main'); // The main content area is our boundary
      //   // Set the pointer cursor on the circles
      //   circles.style('cursor', 'pointer');
      //   circles
      //     .on('mouseover', function (event, d) {
      //       d3.select(this).transition().duration(150).attr('r', 7);
      //       // 1. Set content and make tooltip visible to measure its size
      //       // add time also
      //       tooltip
      //         .html(
      //           `<div class="tooltip-date">${d3.timeFormat('%A, %B %d, %Y')(
      //             d.ctime
      //           )}</div><div class="version-item"><span class="version-color" style="background-color:${colorScale(
      //             d.branch
      //           )}"></span><span class="version-name">${
      //             d.branch
      //           }</span><span class="version-value">${d.metric.toFixed(
      //             2
      //           )}</span></div><div class="commit-details"><strong>Revision:</strong> ${d.revision.substring(
      //             0,
      //             10
      //           )}...<br><a href="https://github.com/postgres/postgres/commit/${
      //             d.revision
      //           }" target="_blank">View on GitHub</a></div>`
      //         )
      //         .classed('show', true);

      //       // 2. Get dimensions
      //       const tooltipNode = tooltip.node();
      //       const tooltipWidth = tooltipNode.offsetWidth;
      //       const tooltipHeight = tooltipNode.offsetHeight;
      //       const containerRect = container.node().getBoundingClientRect();
      //       const offset = 15; // Space between point and tooltip

      //       // 3. Get the CIRCLE's screen position, not the mouse's. This is the key fix.
      //       const point = DOMElements.svg.node().createSVGPoint();
      //       point.x = xScale(d.ctime) + margin.left;
      //       point.y = yScale(d.metric) + margin.top;
      //       const screenPos = point.matrixTransform(
      //         DOMElements.svg.node().getScreenCTM()
      //       );

      //       // Convert the circle's absolute screen position to be relative to the container
      //       const pointX = screenPos.x - containerRect.left;
      //       const pointY = screenPos.y - containerRect.top;

      //       // --- OVERFLOW-AWARE POSITIONING LOGIC ---
      //       const placements = ['top', 'right', 'bottom', 'left'];
      //       let finalPlacement = '';
      //       let finalLeft = 0;
      //       let finalTop = 0;

      //       for (const placement of placements) {
      //         let left, top;
      //         switch (placement) {
      //           case 'top':
      //             left = pointX - tooltipWidth / 2;
      //             top = pointY - tooltipHeight - offset;
      //             break;
      //           case 'right':
      //             left = pointX + offset;
      //             top = pointY - tooltipHeight / 2;
      //             break;
      //           case 'bottom':
      //             left = pointX - tooltipWidth / 2;
      //             top = pointY + offset;
      //             break;
      //           case 'left':
      //             left = pointX - tooltipWidth - offset;
      //             top = pointY - tooltipHeight / 2;
      //             break;
      //         }

      //         if (
      //           checkBounds(
      //             left,
      //             top,
      //             tooltipWidth,
      //             tooltipHeight,
      //             containerRect.width,
      //             containerRect.height
      //           )
      //         ) {
      //           finalPlacement = placement;
      //           finalLeft = left;
      //           finalTop = top;
      //           break; // Found a valid placement
      //         }
      //       }

      //       // Fallback if no position fits
      //       if (!finalPlacement) {
      //         finalPlacement = 'top';
      //         finalLeft = pointX - tooltipWidth / 2;
      //         finalTop = pointY - tooltipHeight - offset;
      //       }

      //       const arrowMap = {
      //         top: 'arrow-down',
      //         right: 'arrow-left',
      //         bottom: 'arrow-up',
      //         left: 'arrow-right',
      //       };

      //       tooltip
      //         .attr('class', 'tooltip show') // Reset classes
      //         .classed(arrowMap[finalPlacement], true)
      //         .style('left', `${finalLeft + 16}px`)
      //         .style('top', `${finalTop + 18}px`);
      //     })
      //     .on('mouseout', function () {
      //       d3.select(this).transition().duration(150).attr('r', 4);
      //       if (!tooltip.node().matches(':hover')) {
      //         tooltip.classed('show', false);
      //       }
      //     });

      //   // Add a listener to the tooltip itself
      //   tooltip.on('mouseleave', () => {
      //     tooltip.classed('show', false);
      //   });
      // }

      function setupTooltip(circles, colorScale, xScale, yScale, margin) {
        const tooltip = DOMElements.tooltip;
        const container = d3.select('main');
        const offset = 0;
        const arrowMap = {
          top: 'arrow-down',
          right: 'arrow-left',
          bottom: 'arrow-up',
          left: 'arrow-right',
        };

        // Pre-calculate static elements
        const tooltipNode = tooltip.node();
        const containerRect = container.node().getBoundingClientRect();

        circles
          .style('cursor', 'pointer')
          .on('mouseover', function (event, d) {
            const circle = d3
              .select(this)
              .style('cursor', 'pointer')
              .transition()
              .duration(150)
              .attr('r', 7);

            tooltip
              .html(
                `<div class="tooltip-date">${d3.timeFormat('%A, %B %d, %Y')(
                  d.ctime
                )}</div>
                <div class="version-item">
                    <span class="version-color" style="background-color:${colorScale(
                      d.branch
                    )}"></span>
                    <span class="version-name">${d.branch}</span>
                    <span class="version-value">${d.metric.toFixed(2)}</span>
                </div>
                <div class="commit-details">
                    <strong>Revision:</strong> ${d.revision.substring(
                      0,
                      10
                    )}...<br>
                    <a href="https://github.com/postgres/postgres/commit/${
                      d.revision
                    }" target="_blank">View on GitHub</a>
                </div>`
              )
              .classed('show', true);

            // Get dimensions after content is set
            const tooltipWidth = tooltipNode.offsetWidth;
            const tooltipHeight = tooltipNode.offsetHeight;

            // Calculate position
            const point = DOMElements.svg.node().createSVGPoint();
            point.x = xScale(d.ctime) + margin.left;
            point.y = yScale(d.metric) + margin.top;
            const screenPos = point.matrixTransform(
              DOMElements.svg.node().getScreenCTM()
            );
            const pointX = screenPos.x - containerRect.left;
            const pointY = screenPos.y - containerRect.top;

            // Simplified positioning logic (you can keep your original if needed)
            let left = pointX - tooltipWidth / 2;
            let top = pointY - tooltipHeight - offset;
            let placement = 'top';

            // Adjust if out of bounds (simplified example)
            if (top < 0) {
              top = pointY + offset;
              placement = 'bottom';
            }
            if (left < 0) left = 0;
            if (left + tooltipWidth > containerRect.width)
              left = containerRect.width - tooltipWidth;

            tooltip
              .attr('class', 'tooltip show')
              .classed(arrowMap[placement], true)
              .style('left', `${left}px`)
              .style('top', `${top}px`);
          })
          .on('mouseout', function () {
            d3.select(this)
              .style('cursor', 'pointer')
              .transition()
              .duration(150)
              .attr('r', 4);

            // Use setTimeout to allow for cursor to move to tooltip
            setTimeout(() => {
              if (!tooltip.node().matches(':hover')) {
                tooltip.classed('show', false);
              }
            }, 50);
          });

        tooltip.on('mouseleave', () => {
          tooltip.classed('show', false);
        });
      }

      // function renderLegend(branches, colorScale) {
      //   console.log('Rendering legend with branches:', branches);
      //   console.log('Color scale domain:', colorScale.domain());
      //   console.log('Color scale range:', colorScale.range());

      //   // Debug each branch color
      //   branches.forEach((branch) => {
      //     console.log(`Branch: ${branch}, Color: ${colorScale(branch)}`);
      //   });

      //   const { legendContainer } = DOMElements;
      //   legendContainer
      //     .selectAll('.legend-item')
      //     .data(branches, (d) => d)
      //     .join(
      //       (enter) => {
      //         const item = enter
      //           .append('div')
      //           .attr('class', 'legend-item')
      //           .attr('data-branch', (d) => d);
      //         item
      //           .html((d) => `${BRANCH_ICON_SVG}<span>${d}</span>`)
      //           .each(function (d) {
      //             console.log(`Setting color for branch ${d}:`, colorScale(d));

      //             d3.select(this)
      //               .select('svg path')
      //               .attr('fill', colorScale(d));
      //           });
      //         item.on('click', (event, d) => {
      //           const checkbox = DOMElements.branchListContainer.querySelector(
      //             `input[value="${d}"]`
      //           );
      //           if (checkbox) {
      //             checkbox.checked = !checkbox.checked;
      //             checkbox.dispatchEvent(
      //               new Event('change', { bubbles: true })
      //             );
      //           }
      //         });
      //         return item;
      //       },
      //       (update) => update,
      //       (exit) => exit.remove()
      //     )
      //     .classed('inactive', (d) => !currentFilters.branches.includes(d));
      // }
      function renderLegend(branches, colorScale) {
        console.log('Rendering legend with branches:', branches);

        const { legendContainer } = DOMElements;

        const items = legendContainer
          .selectAll('.legend-item')
          .data(branches, (d) => d)
          .join(
            (enter) => {
              const item = enter
                .append('div')
                .attr('class', 'legend-item')
                .attr('data-branch', (d) => d);

              item.on('click', (event, d) => {
                const checkbox = DOMElements.branchListContainer.querySelector(
                  `input[value="${d}"]`
                );
                if (checkbox) {
                  checkbox.checked = !checkbox.checked;
                  checkbox.dispatchEvent(
                    new Event('change', { bubbles: true })
                  );
                }
              });
              return item;
            },
            (update) => update, // Return update selection
            (exit) => exit.remove()
          );

        // Apply HTML and colors to ALL items (both new and existing)
        items
          .html((d) => `${BRANCH_ICON_SVG}<span>${d}</span>`)
          .each(function (d) {
            console.log(`Setting color for branch ${d}:`, colorScale(d));
            d3.select(this).select('svg path').attr('fill', colorScale(d));
          });

        // Apply inactive class to ALL items
        items.classed('inactive', (d) => !currentFilters.branches.includes(d));
      }

      function updateLastUpdated(data) {
        if (!data || data.length === 0) return;
        const maxDate = d3.max(data, (d) => d.ctime);
        DOMElements.lastUpdated.textContent = `Last updated: ${d3.timeFormat(
          '%b %d, %Y'
        )(maxDate)}`;
      }

      function parseCSV(csvText) {
        const lines = csvText.trim().split('\n');
        if (lines.length < 2) return [];
        const headers = lines[0].split(',').map((h) => h.trim());
        return lines.slice(1).map((line) => {
          const values = line.match(/(".*?"|[^",\n]+)(?=\s*,|\s*$)/g) || [];
          return headers.reduce((obj, header, i) => {
            obj[header] = values[i]
              ? values[i].replace(/^"|"$/g, '').trim()
              : '';
            return obj;
          }, {});
        });
      }

      function handleError(error) {
        console.error('Error:', error);
        DOMElements.svg.selectAll('*').remove();
        DOMElements.svg
          .append('text')
          .attr('x', '50%')
          .attr('y', '50%')
          .attr('text-anchor', 'middle')
          .attr('fill', 'red')
          .text(`Error: ${error.message}`);
      }
    </script>
  </body>
</html>
