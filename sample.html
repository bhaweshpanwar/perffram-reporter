<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Fireweed Performance Chart</title>
    <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
    <style>
      body {
        font-family: 'Inter', sans-serif;
        margin: 20px;
      }
      #chart-container {
        margin: 20px auto;
        max-width: 1200px;
      }
      .tooltip {
        position: absolute;
        opacity: 0;
        background-color: white;
        color: #333;
        padding: 15px;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        border: 1px solid #e2e8f0;
        font-size: 13px;
        line-height: 1.6;
        white-space: nowrap;
        transition: opacity 0.2s ease-in-out;
        z-index: 1000;
        min-width: 300px;
      }
      .tooltip .tooltip-date {
        font-size: 12px;
        color: #718096;
        margin-bottom: 10px;
        padding-bottom: 5px;
        border-bottom: 1px solid #e2e8f0;
      }
      .tooltip strong {
        font-weight: 600;
        color: #4a5568;
        display: inline-block;
        min-width: 100px;
      }
      .tooltip .version-item {
        display: flex;
        align-items: center;
        margin-bottom: 4px;
      }
      .tooltip .version-color {
        width: 12px;
        height: 12px;
        border-radius: 50%;
        margin-right: 8px;
        display: inline-block;
        flex-shrink: 0;
      }
      .tooltip .version-name {
        flex-grow: 1;
        margin-right: 10px;
      }
      .tooltip .version-value {
        font-weight: 600;
        text-align: right;
      }
      .tooltip .commit-details {
        margin-top: 12px;
        padding-top: 12px;
        border-top: 1px solid #e2e8f0;
      }
      .tooltip .commit-message {
        display: block;
        margin-top: 5px;
        max-width: 280px;
        white-space: normal;
        color: #718096;
        font-style: italic;
        font-size: 12px;
        line-height: 1.4;
      }
      .tooltip a {
        color: #4299e1;
        text-decoration: none;
        display: block;
        margin-top: 8px;
        font-size: 12px;
      }
      .tooltip a:hover {
        text-decoration: underline;
      }
      .branch-legend {
        margin-top: 20px;
        text-align: center;
      }
      .legend-item {
        display: inline-flex;
        align-items: center;
        margin: 0 8px 8px 8px;
        font-size: 12px;
        cursor: pointer;
        padding: 4px 6px;
        border-radius: 4px;
      }
      .legend-item:hover {
        background-color: #f3f4f6;
      }
      .legend-color {
        display: inline-block;
        width: 12px;
        height: 12px;
        margin-right: 6px;
        border-radius: 3px;
        flex-shrink: 0;
      }
      .axis path,
      .axis line {
        stroke: #d1d5db;
        shape-rendering: crispEdges;
      }
      .axis text {
        fill: #4b5563;
        font-size: 11px;
      }
      .grid .tick line {
        stroke: #e5e7eb;
        stroke-opacity: 0.7;
      }
      .grid path {
        stroke-width: 0;
      }
      text.axis-label {
        fill: #1f2937;
        font-size: 13px;
        font-weight: 500;
      }
    </style>
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap"
      rel="stylesheet"
    />
  </head>
  <body>
    <div id="chart-container">
      <h1>Fireweed Performance Metrics</h1>
      <svg id="chart" width="100%" height="500"></svg>
      <div id="legend" class="branch-legend"></div>
      <div id="tooltip" class="tooltip"></div>
    </div>

    <script>
      let allData = [];
      const chartGlobals = {
        margin: { top: 50, right: 40, bottom: 60, left: 70 },
        width: 0,
        height: 0,
        x: d3.scaleTime(),
        y: d3.scaleLinear(),
        color: d3.scaleOrdinal(d3.schemeTableau10),
        lineGenerator: null,
        mainGroup: null,
        xAxisG: null,
        yAxisG: null,
        xAxisGridG: null,
        yAxisGridG: null,
      };

      const svgD3 = d3.select('#chart');
      const tooltipD3 = d3.select('#tooltip');
      const legendContainerD3 = d3.select('#legend');

      async function loadAndProcessData() {
        try {
          const response = await fetch('./fireweed.csv');
          if (!response.ok)
            throw new Error(`Failed to load CSV file: ${response.status}`);
          const csvText = await response.text();

          const rawData = parseCSV(csvText);

          if (!rawData || !Array.isArray(rawData))
            throw new Error('Invalid data format in CSV file');
          if (rawData.length === 0)
            throw new Error('No data found in CSV file');

          allData = rawData.map((d) => ({
            branch: d.branch,
            revision: d.revision,
            scale: +d.scale,
            ctime: new Date(d.ctime * 1000),
            metric: +d.metric,
            complete_at: new Date(d.complete_at * 1000),
            test: 'dbt2',
            machine: 'fireweed',
            commit_message: `Commit ${d.revision.substring(0, 7)}`,
          }));

          setupChart();
          updateChartUI(allData);
          handleResize();
        } catch (error) {
          console.error('Error loading or processing data:', error);
          document.getElementById(
            'chart-container'
          ).innerHTML = `<div class="error">Error loading data: ${error.message}</div>`;
        }
      }

      function parseCSV(csvText) {
        const trimmedCsvText = csvText.trim();
        if (!trimmedCsvText) return [];

        const lines = trimmedCsvText.split('\n');
        if (lines.length < 2) return [];

        const headers = lines[0].split(',').map((h) => h.trim());

        return lines
          .slice(1)
          .filter((line) => line.trim() !== '')
          .map((line) => {
            const values = line.split(',');
            const entry = {};
            headers.forEach((header, i) => {
              entry[header] = values[i] !== undefined ? values[i].trim() : '';
            });
            return entry;
          });
      }

      function setupChart() {
        chartGlobals.mainGroup = svgD3
          .append('g')
          .attr(
            'transform',
            `translate(${chartGlobals.margin.left},${chartGlobals.margin.top})`
          );

        chartGlobals.xAxisGridG = chartGlobals.mainGroup
          .append('g')
          .attr('class', 'x-grid grid');
        chartGlobals.yAxisGridG = chartGlobals.mainGroup
          .append('g')
          .attr('class', 'y-grid grid');
        chartGlobals.xAxisG = chartGlobals.mainGroup
          .append('g')
          .attr('class', 'x-axis axis');
        chartGlobals.yAxisG = chartGlobals.mainGroup
          .append('g')
          .attr('class', 'y-axis axis');

        svgD3
          .append('text')
          .attr('class', 'axis-label x-label')
          .style('text-anchor', 'middle')
          .text('Commit Date');

        svgD3
          .append('text')
          .attr('class', 'axis-label y-label')
          .attr('transform', 'rotate(-90)')
          .style('text-anchor', 'middle')
          .text('Metric Value');

        chartGlobals.lineGenerator = d3
          .line()
          .x((d) => chartGlobals.x(d.ctime))
          .y((d) => chartGlobals.y(d.metric))
          .curve(d3.curveMonotoneX);
      }

      function updateChartUI(dataToDraw) {
        const {
          x,
          y,
          color,
          lineGenerator,
          margin,
          mainGroup,
          xAxisG,
          yAxisG,
          xAxisGridG,
          yAxisGridG,
        } = chartGlobals;

        if (!dataToDraw || dataToDraw.length === 0) {
          mainGroup.selectAll('*').remove();
          xAxisG.selectAll('*').remove();
          yAxisG.selectAll('*').remove();
          xAxisGridG.selectAll('*').remove();
          yAxisGridG.selectAll('*').remove();

          mainGroup
            .append('text')
            .attr('class', 'no-data-message')
            .attr('x', chartGlobals.width / 2)
            .attr('y', chartGlobals.height / 2)
            .attr('text-anchor', 'middle')
            .style('font-size', '16px')
            .text('No data available.');
          updateLegend([]);
          return;
        }
        mainGroup.select('.no-data-message').remove();

        const xExtent = d3.extent(dataToDraw, (d) => d.ctime);
        const yMinOriginal = d3.min(dataToDraw, (d) => d.metric);
        const yMaxOriginal = d3.max(dataToDraw, (d) => d.metric);

        let yPadding = (yMaxOriginal - yMinOriginal) * 0.1;
        if (yPadding === 0 && yMaxOriginal === yMinOriginal)
          yPadding = yMaxOriginal === 0 ? 1 : Math.abs(yMaxOriginal * 0.1);
        if (yPadding === 0 && yMaxOriginal !== yMinOriginal) yPadding = 0.1;

        const yDomainMin = yMinOriginal - yPadding;
        const yDomainMax = yMaxOriginal + yPadding;

        x.domain(xExtent).range([0, chartGlobals.width]);
        y.domain([yDomainMin, yDomainMax])
          .nice()
          .range([chartGlobals.height, 0]);

        const dateFormat = d3.timeFormat('%d-%b-%y');
        let xAxisCall = d3.axisBottom(x).tickFormat(dateFormat);
        const timeSpanDays =
          x.domain()[1] && x.domain()[0]
            ? (x.domain()[1] - x.domain()[0]) / (1000 * 60 * 60 * 24)
            : 0;
        const numTicksTarget = Math.min(
          10,
          Math.max(5, Math.floor(chartGlobals.width / 100))
        );
        xAxisCall.ticks(numTicksTarget);

        xAxisG
          .attr('transform', `translate(0,${chartGlobals.height})`)
          .transition()
          .duration(300)
          .call(xAxisCall);

        yAxisG
          .transition()
          .duration(300)
          .call(d3.axisLeft(y).ticks(5).tickFormat(d3.format(',')));

        // Adjust grid lines
        const xTickValues = xAxisG
          .selectAll('.tick')
          .data()
          .map((d) => (d instanceof Date ? d : new Date(d)));
        const yTickValues = yAxisG.selectAll('.tick').data();

        xAxisGridG
          .attr('transform', `translate(0,${chartGlobals.height})`)
          .transition()
          .duration(300)
          .call(
            d3
              .axisBottom(x)
              .tickValues(xTickValues)
              .tickSize(-chartGlobals.height)
              .tickFormat('')
          );

        yAxisGridG
          .transition()
          .duration(300)
          .call(
            d3
              .axisLeft(y)
              .tickValues(yTickValues)
              .tickSize(-chartGlobals.width)
              .tickFormat('')
          );

        svgD3
          .select('.axis-label.x-label')
          .attr(
            'transform',
            `translate(${margin.left + chartGlobals.width / 2},${
              margin.top + chartGlobals.height + margin.bottom - 20
            })`
          );

        svgD3
          .select('.axis-label.y-label')
          .attr('y', margin.left / 2 - 15)
          .attr('x', 0 - (margin.top + chartGlobals.height / 2));

        const dataByBranch = d3.group(dataToDraw, (d) => d.branch);
        color.domain(dataByBranch.keys());

        // Draw lines
        const series = mainGroup
          .selectAll('.data-series-group')
          .data(Array.from(dataByBranch), ([branch]) => branch);

        series.exit().transition().duration(300).style('opacity', 0).remove();
        const seriesEnter = series
          .enter()
          .append('g')
          .attr('class', 'data-series-group');

        seriesEnter
          .append('path')
          .attr('class', 'line')
          .style('fill', 'none')
          .style('stroke-width', 1.5);

        series
          .merge(seriesEnter)
          .select('.line')
          .transition()
          .duration(300)
          .attr('d', ([, values]) =>
            lineGenerator(values.sort((a, b) => a.ctime - b.ctime))
          )
          .style('stroke', ([branch]) => color(branch));

        const allPoints = mainGroup
          .selectAll('.point')
          .data(
            dataToDraw,
            (d) => `${d.branch}-${d.revision}-${d.ctime.getTime()}`
          );

        allPoints.exit().transition().duration(300).attr('r', 0).remove();

        allPoints
          .enter()
          .append('circle')
          .attr('class', 'point')
          .attr('r', 0)
          .on('mouseover', showTooltip)
          .on('mouseout', hideTooltip)
          .merge(allPoints)
          .style('fill', (d) => color(d.branch))
          .transition()
          .duration(300)
          .attr('cx', (d) => x(d.ctime))
          .attr('cy', (d) => y(d.metric))
          .attr('r', 2);

        updateLegend(Array.from(dataByBranch.keys()));
      }

      function updateLegend(branches) {
        legendContainerD3.selectAll('.legend-item').remove();

        branches.forEach((branch) => {
          legendContainerD3
            .append('div')
            .attr('class', 'legend-item')
            .attr('data-branch', branch)
            .html(
              `<span class="legend-color" style="background-color:${chartGlobals.color(
                branch
              )};"></span> ${branch}`
            );
        });
      }

      function showTooltip(event, d) {
        tooltipD3.style('pointer-events', 'auto');

        const formattedDate = d.ctime.toLocaleDateString(undefined, {
          year: 'numeric',
          month: 'short',
          day: 'numeric',
          hour: '2-digit',
          minute: '2-digit',
        });
        const shortHash = d.revision.substring(0, 7);
        const commitLink = `https://github.com/postgres/postgres/commit/${d.revision}`;

        tooltipD3.transition().duration(100).style('opacity', 0.95);
        tooltipD3.html(`
                <div class="tooltip-date">${formattedDate}</div>
                <div class="version-item">
                    <span class="version-color" style="background-color:${chartGlobals.color(
                      d.branch
                    )}"></span>
                    <span class="version-name">${d.branch}</span>
                    <span class="version-value">${d3.format(',.1f')(
                      d.metric
                    )}</span>
                </div>
                <div class="commit-details">
                    <strong>Commit Hash:</strong> ${shortHash}<br>
                    <strong>Commit Message:</strong> <span class="commit-message">${
                      d.commit_message || 'N/A'
                    }</span>
                    <a href="${commitLink}" target="_blank" rel="noopener noreferrer">View Full Commit Details</a>
                </div>`);

        const [mouseX, mouseY] = d3.pointer(
          event,
          chartGlobals.mainGroup.node()
        );
        const mainGroupRect = chartGlobals.mainGroup
          .node()
          .getBoundingClientRect();
        const bodyRect = document.body.getBoundingClientRect();

        let left =
          mainGroupRect.left - bodyRect.left + mouseX + 15 + window.scrollX;
        let top =
          mainGroupRect.top - bodyRect.top + mouseY - 15 + window.scrollY;

        const tooltipNode = tooltipD3.node();
        const tooltipHeight = tooltipNode.offsetHeight;
        const tooltipWidth = tooltipNode.offsetWidth;

        // Adjust position if tooltip would go off screen
        if (left + tooltipWidth > window.innerWidth + window.scrollX - 10) {
          left =
            mainGroupRect.left -
            bodyRect.left +
            mouseX -
            15 -
            tooltipWidth +
            window.scrollX;
        }
        if (top < window.scrollY + 10) {
          top = window.scrollY + 10;
        }
        if (top + tooltipHeight > window.innerHeight + window.scrollY - 10) {
          top = window.innerHeight + window.scrollY - tooltipHeight - 10;
        }
        if (left < window.scrollX + 10) {
          left = window.scrollX + 10;
        }

        tooltipD3.style('left', `${left}px`).style('top', `${top}px`);
        d3.select(event.currentTarget)
          .transition()
          .duration(50)
          .attr('r', 4)
          .style('stroke', '#333')
          .style('stroke-width', 1.5);
      }

      function hideTooltip(event) {
        tooltipD3
          .transition()
          .duration(200)
          .style('opacity', 0)
          .on('end', function () {
            d3.select(this).style('pointer-events', 'none');
          });
        d3.select(event.currentTarget)
          .transition()
          .duration(100)
          .attr('r', 2)
          .style('stroke', 'none');
      }

      function handleResize() {
        const container = document.getElementById('chart-container');
        if (!container) return;

        const newContainerWidth = container.clientWidth;
        const newSvgHeight = Math.max(
          300,
          Math.min(550, newContainerWidth * 0.6)
        );

        chartGlobals.width =
          newContainerWidth -
          chartGlobals.margin.left -
          chartGlobals.margin.right;
        chartGlobals.height =
          newSvgHeight - chartGlobals.margin.top - chartGlobals.margin.bottom;

        chartGlobals.width = Math.max(0, chartGlobals.width);
        chartGlobals.height = Math.max(0, chartGlobals.height);

        svgD3.attr('width', newContainerWidth).attr('height', newSvgHeight);

        if (
          chartGlobals.width > 0 &&
          chartGlobals.height > 0 &&
          allData.length > 0
        ) {
          updateChartUI(allData);
        }
      }

      window.addEventListener('resize', handleResize);
      document.addEventListener('DOMContentLoaded', () => {
        loadAndProcessData();
      });
    </script>
  </body>
</html>
