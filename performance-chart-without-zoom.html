<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>DBT2 Fireweed Performance Chart</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <style>
      html,
      body {
        height: 100%;
        margin: 0;
        overflow: hidden; /* Prevent body scrollbars */
      }
      body {
        font-family: 'Inter', sans-serif;
        display: flex;
        flex-direction: column;
      }
      main {
        flex: 1;
        display: flex;
        flex-direction: column;
        overflow-y: auto; /* Allow main content to scroll if needed */
        padding: 1rem;
      }
      #chart-container {
        flex-grow: 1;
        min-height: 400px;
        width: 100%;
      }

      /* --- D3 Chart Styles --- */
      .axis path,
      .axis line {
        stroke: #333;
        stroke-width: 0.8;
      }
      .axis text {
        fill: #4b5563;
        font-size: 12px;
      }
      .grid path {
        display: none;
      }
      .grid line {
        stroke: #e2e8f0;
      }
      .brush .selection {
        fill: #3b82f6;
        fill-opacity: 0.2;
        stroke: #2563eb;
      }
      .brush .handle {
        fill: #6b7280;
      }

      /* --- Tooltip with Pointer --- */
      .tooltip {
        position: absolute;
        opacity: 0;
        background-color: white;
        color: #333;
        padding: 15px;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        border: 1px solid #e2e8f0;
        font-size: 13px;
        line-height: 1.6;
        white-space: nowrap;
        transition: opacity 0.2s ease-in-out, transform 0.2s ease-in-out;
        z-index: 1000;
        min-width: 300px;
        pointer-events: none;
        transform: translate(-50%, 15px); /* Center tooltip and move it down */
      }
      .tooltip::after,
      .tooltip::before {
        content: '';
        position: absolute;
        bottom: 100%; /* Position arrow at the top of the tooltip */
        left: 50%;
        transform: translateX(-50%);
        width: 0;
        height: 0;
        border-style: solid;
      }
      .tooltip::after {
        /* The white triangle */
        border-width: 0 8px 8px 8px;
        border-color: transparent transparent white transparent;
      }
      .tooltip::before {
        /* The grey border for the triangle */
        border-width: 0 9px 9px 9px;
        border-color: transparent transparent #e2e8f0 transparent;
        bottom: calc(100% + 1px);
      }

      .tooltip .tooltip-date {
        font-size: 12px;
        color: #718096;
        margin-bottom: 10px;
        padding-bottom: 5px;
        border-bottom: 1px solid #e2e8f0;
      }
      .tooltip strong {
        font-weight: 600;
        color: #4a5568;
        display: inline-block;
        min-width: 80px;
      }
      .tooltip .version-item {
        display: flex;
        align-items: center;
        margin-bottom: 4px;
      }
      .tooltip .version-color {
        width: 12px;
        height: 12px;
        border-radius: 50%;
        margin-right: 8px;
        display: inline-block;
        flex-shrink: 0;
      }
      .tooltip .version-name {
        flex-grow: 1;
        margin-right: 10px;
        font-weight: 500;
      }
      .tooltip .version-value {
        font-weight: 600;
        text-align: right;
      }
      .tooltip .commit-details {
        margin-top: 12px;
        padding-top: 12px;
        border-top: 1px solid #e2e8f0;
      }
      .tooltip a {
        color: #4299e1;
        text-decoration: none;
        display: block;
        margin-top: 8px;
        font-size: 12px;
        pointer-events: auto !important;
      }
      .tooltip a:hover {
        text-decoration: underline;
      }

      /* --- Custom Filter Styles --- */
      .form-label {
        display: block;
        font-size: 14px;
        font-weight: 500;
        color: #1f2937;
        margin-bottom: 8px;
      }

      .form-select,
      #branch-select-button {
        appearance: none;
        -webkit-appearance: none;
        -moz-appearance: none;
        padding: 10px 40px 10px 12px;
        font-size: 14px;
        color: #374151; /* Darker text for selected value */
        border: 1px solid #d1d5db;
        border-radius: 6px;
        background-color: white;
        background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 20 20' fill='currentColor'%3E%3Cpath fill-rule='evenodd' d='M5.22 8.22a.75.75 0 0 1 1.06 0L10 11.94l3.72-3.72a.75.75 0 1 1 1.06 1.06l-4.25 4.25a.75.75 0 0 1-1.06 0L5.22 9.28a.75.75 0 0 1 0-1.06Z' clip-rule='evenodd' /%3E%3C/svg%3E");
        background-repeat: no-repeat;
        background-position: right 12px center;
        background-size: 1.25rem;
        width: 100%;
        cursor: pointer;
        outline: none;
        height: 42px;
        text-align: left;
      }
      .form-select:focus,
      #branch-select-button:focus {
        border-color: #3b82f6;
        box-shadow: 0 0 0 1px #3b82f6;
      }
      #branch-select-button {
        color: #374151;
      }

      /* Checkbox Dropdown */
      #branch-filter-dropdown {
        display: none;
        position: absolute;
        background-color: white;
        border: 1px solid #d1d5db;
        border-radius: 0.375rem;
        box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1),
          0 2px 4px -2px rgba(0, 0, 0, 0.1);
        z-index: 10;
        margin-top: 0.25rem;
        width: 100%;
        padding: 0.5rem;
      }
      .branch-filter-actions {
        display: flex;
        justify-content: space-between;
        padding: 0.5rem;
        border-bottom: 1px solid #e5e7eb;
      }
      .branch-filter-actions button {
        font-size: 0.75rem;
        color: #2563eb;
        font-weight: 500;
        background: none;
        border: none;
        padding: 0.25rem;
        cursor: pointer;
      }
      #branch-list-container {
        max-height: 200px;
        overflow-y: auto;
        padding: 0.5rem;
      }
      #branch-list-container label {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        font-weight: 400;
        font-size: 0.875rem;
        margin-bottom: 0.5rem;
        cursor: pointer;
        color: #374151;
      }

      /* --- Legend Styles --- */
      .legend-container {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        gap: 0.5rem 1.5rem;
        margin-top: 1rem;
        padding: 1rem 0;
      }
      .legend-item {
        display: flex;
        align-items: center;
        cursor: pointer;
        font-size: 0.875rem;
        color: #374151;
        transition: opacity 0.2s;
      }
      .legend-item.inactive {
        opacity: 0.4;
      }
      .legend-item svg {
        width: 24px;
        height: 24px;
        margin-right: 0.25rem;
      }
    </style>
  </head>
  <body class="bg-gray-50">
    <main>
      <header
        class="flex justify-between items-start mb-4 pb-4 border-b border-gray-200"
      >
        <div>
          <h1 class="text-xl font-semibold text-gray-800">
            DBT2 Test Results on Fireweed
          </h1>
          <div
            id="activeFiltersDisplay"
            class="text-sm text-gray-500 mt-1 font-medium"
          ></div>
        </div>
        <div>
          <p
            id="lastUpdated"
            class="text-sm text-gray-600 font-medium text-right"
          ></p>
        </div>
      </header>

      <!-- Filters Section -->
      <section
        class="grid grid-cols-1 md:grid-cols-3 lg:grid-cols-4 gap-6 mb-6"
      >
        <div class="filter-group">
          <label for="chooseScale" class="form-label text-gray-700"
            >Scale Factor</label
          >
          <select
            id="chooseScale"
            name="chooseScale"
            class="form-select"
          ></select>
        </div>

        <div class="filter-group relative">
          <label for="branch-select-button" class="form-label text-gray-700"
            >Choose Branches</label
          >
          <button id="branch-select-button" class="w-full">
            Select Branches
          </button>
          <div id="branch-filter-dropdown" class="w-full">
            <div class="branch-filter-actions">
              <button id="branch-select-all">Select All</button>
              <button id="branch-deselect-all">Deselect All</button>
            </div>
            <div id="branch-list-container"></div>
          </div>
        </div>
      </section>

      <div id="chart-container">
        <svg id="chart-svg" width="100%" height="100%"></svg>
      </div>

      <div id="legend-container" class="legend-container"></div>

      <div class="text-xs text-gray-500 mt-2 space-y-1 text-center">
        <p>
          <span class="font-semibold">Tip:</span> Double-click the main chart to
          reset the zoom level.
        </p>
      </div>

      <div class="tooltip"></div>
    </main>
    <script>
      // --- GLOBAL STATE AND CONSTANTS ---
      let allData = [];
      let fullXDomain, fullYDomain; // To store the full domains for resetting
      const currentFilters = { scale: null, branches: [] };
      const DOMElements = {};
      const BRANCH_ICON_SVG = `<svg viewBox="0 0 256 256" xmlns="http://www.w3.org/2000/svg"><rect fill="none" height="256" width="256"/><path d="M248,120H187.5a60,60,0,0,0-118.9,0H8a8,8,0,0,0,0,16H68.6a60,60,0,0,0,118.9,0H248a8,8,0,0,0,0-16Z"/></svg>`;
      const SERIOUS_COLORS = [
        '#1f77b4',
        '#ff7f0e',
        '#2ca02c',
        '#d62728',
        '#9467bd',
        '#8c564b',
        '#e377c2',
        '#7f7f7f',
        '#bcbd22',
        '#17becf',
      ];

      // --- DEBOUNCE UTILITY ---
      function debounce(func, wait) {
        let timeout;
        return function (...args) {
          const context = this;
          clearTimeout(timeout);
          timeout = setTimeout(() => func.apply(context, args), wait);
        };
      }

      // --- INITIALIZATION ---
      document.addEventListener('DOMContentLoaded', () => {
        cacheDOMElements();
        fetch('./fireweed.csv')
          .then((response) => {
            if (!response.ok)
              throw new Error(`Failed to load CSV: ${response.statusText}`);
            return response.text();
          })
          .then((csvText) => {
            const rawData = parseCSV(csvText);
            if (!rawData || !Array.isArray(rawData) || rawData.length === 0)
              throw new Error('No valid data in CSV');
            allData = rawData.map((d) => ({
              branch: d.branch || 'unknown',
              revision: d.revision,
              scale: +d.scale,
              ctime: new Date(d.ctime * 1000),
              metric: +d.metric,
              commit_message: d.commit_message || `Commit: ${d.revision}`,
            }));
            initializeApp(allData);
          })
          .catch(handleError);
      });

      function initializeApp(data) {
        setupFilterControls(data);
        setupEventListeners();
        applyFiltersAndRender();
        updateLastUpdated(data);
        window.addEventListener('resize', debounce(applyFiltersAndRender, 150));
      }

      // --- DOM & EVENT SETUP ---
      function cacheDOMElements() {
        DOMElements.chartContainer = document.getElementById('chart-container');
        DOMElements.svg = d3.select('#chart-svg');
        DOMElements.tooltip = d3.select('.tooltip');
        DOMElements.scaleFilter = document.getElementById('chooseScale');
        DOMElements.activeFiltersDisplay = document.getElementById(
          'activeFiltersDisplay'
        );
        DOMElements.legendContainer = d3.select('#legend-container');
        DOMElements.lastUpdated = document.getElementById('lastUpdated');
        DOMElements.branchSelectButton = document.getElementById(
          'branch-select-button'
        );
        DOMElements.branchFilterDropdown = document.getElementById(
          'branch-filter-dropdown'
        );
        DOMElements.branchListContainer = document.getElementById(
          'branch-list-container'
        );
        DOMElements.branchSelectAll =
          document.getElementById('branch-select-all');
        DOMElements.branchDeselectAll = document.getElementById(
          'branch-deselect-all'
        );
      }

      function setupFilterControls(data) {
        const uniqueScales = [...new Set(data.map((d) => d.scale))].sort(
          (a, b) => a - b
        );
        DOMElements.scaleFilter.innerHTML = '';
        uniqueScales.forEach((scale) => {
          const option = document.createElement('option');
          option.value = scale;
          option.textContent = scale;
          DOMElements.scaleFilter.appendChild(option);
        });
        currentFilters.scale = uniqueScales[0] || null;
        DOMElements.scaleFilter.value = currentFilters.scale;
        updateBranchFilter();
      }

      function setupEventListeners() {
        DOMElements.scaleFilter.addEventListener('change', (e) => {
          currentFilters.scale = +e.target.value;
          updateBranchFilter(true);
          applyFiltersAndRender();
        });

        DOMElements.branchSelectButton.addEventListener('click', () => {
          const isHidden =
            DOMElements.branchFilterDropdown.style.display === 'none' ||
            !DOMElements.branchFilterDropdown.style.display;
          DOMElements.branchFilterDropdown.style.display = isHidden
            ? 'block'
            : 'none';
        });

        document.addEventListener('click', (e) => {
          if (
            !DOMElements.branchSelectButton.contains(e.target) &&
            !DOMElements.branchFilterDropdown.contains(e.target)
          ) {
            DOMElements.branchFilterDropdown.style.display = 'none';
          }
        });

        DOMElements.branchListContainer.addEventListener('change', (e) => {
          if (e.target.type === 'checkbox') {
            currentFilters.branches = Array.from(
              DOMElements.branchListContainer.querySelectorAll('input:checked')
            ).map((cb) => cb.value);
            updateBranchButtonText();
            applyFiltersAndRender();
          }
        });

        DOMElements.branchSelectAll.addEventListener('click', () =>
          toggleAllBranches(true)
        );
        DOMElements.branchDeselectAll.addEventListener('click', () =>
          toggleAllBranches(false)
        );
      }

      // --- FILTER LOGIC ---
      function applyFiltersAndRender() {
        const dataForScale = allData.filter(
          (d) => d.scale === currentFilters.scale
        );
        const allBranchesForScale = [
          ...new Set(dataForScale.map((d) => d.branch)),
        ]
          .sort()
          .reverse();
        const colorScale = d3
          .scaleOrdinal(SERIOUS_COLORS)
          .domain(allBranchesForScale);
        const filteredData = dataForScale.filter((d) =>
          currentFilters.branches.includes(d.branch)
        );

        renderChart(filteredData, dataForScale, colorScale);
        renderLegend(allBranchesForScale, colorScale);
        updateActiveFiltersDisplay();
      }

      function updateBranchFilter(reset = true) {
        const availableBranches = [
          ...new Set(
            allData
              .filter((d) => d.scale === currentFilters.scale)
              .map((d) => d.branch)
          ),
        ]
          .sort()
          .reverse();
        if (reset) {
          currentFilters.branches = [...availableBranches];
        }

        DOMElements.branchListContainer.innerHTML = '';
        availableBranches.forEach((branch) => {
          const id = `branch-cb-${branch.replace(/\W/g, '-')}`;
          const isChecked = currentFilters.branches.includes(branch);
          const label = document.createElement('label');
          label.setAttribute('for', id);
          label.innerHTML = `<input type="checkbox" id="${id}" value="${branch}" ${
            isChecked ? 'checked' : ''
          }><span>${branch}</span>`;
          DOMElements.branchListContainer.appendChild(label);
        });
        updateBranchButtonText();
      }

      function updateBranchButtonText() {
        const count = currentFilters.branches.length;
        const total =
          DOMElements.branchListContainer.querySelectorAll('input').length;
        if (count === 0)
          DOMElements.branchSelectButton.textContent = 'No Branches Selected';
        else if (count === total)
          DOMElements.branchSelectButton.textContent = 'All Branches Selected';
        else
          DOMElements.branchSelectButton.textContent = `${count} Branches Selected`;
      }

      function toggleAllBranches(select) {
        const checkboxes =
          DOMElements.branchListContainer.querySelectorAll('input');
        checkboxes.forEach((cb) => (cb.checked = select));
        currentFilters.branches = select
          ? Array.from(checkboxes).map((cb) => cb.value)
          : [];
        updateBranchButtonText();
        applyFiltersAndRender();
      }

      // --- RENDERING ---
      function renderChart(data, dataForContext, colorScale) {
        const { svg, chartContainer } = DOMElements;
        svg.selectAll('*').remove();
        if (data.length === 0) {
          svg
            .append('text')
            .attr('x', '50%')
            .attr('y', '50%')
            .attr('text-anchor', 'middle')
            .text('No data for selected filters.')
            .style('fill', '#6b7280');
          return;
        }

        const containerRect = chartContainer.getBoundingClientRect();
        const width = containerRect.width;
        const height = containerRect.height;
        const margin = { top: 20, right: 30, bottom: 120, left: 60 };
        const chartWidth = width - margin.left - margin.right;
        const chartHeight = height - margin.top - margin.bottom;

        if (chartWidth <= 0 || chartHeight <= 0) return;

        // Store initial domains for reset
        fullXDomain = d3.extent(dataForContext, (d) => d.ctime);
        fullYDomain = [0, d3.max(dataForContext, (d) => d.metric) * 1.05];

        const xScale = d3
          .scaleTime()
          .domain(fullXDomain)
          .range([0, chartWidth]);
        // const yScale = d3
        //   .scaleLinear()
        //   .domain(fullYDomain)
        //   .range([chartHeight, 0])
        //   .nice();

        const yScale = d3
          .scaleLinear()
          .domain([
            d3.min(data, (d) => d.metric) * 0.95, // 5% below min
            d3.max(data, (d) => d.metric) * 1.05, // 5% above max
          ])
          .range([chartHeight, 0]);

        svg
          .append('defs')
          .append('clipPath')
          .attr('id', 'chart-clip')
          .append('rect')
          .attr('width', chartWidth)
          .attr('height', chartHeight);

        const chart = svg
          .append('g')
          .attr('transform', `translate(${margin.left}, ${margin.top})`);

        const xAxis = d3
          .axisBottom(xScale)
          .ticks(width / 100)
          .tickFormat(d3.timeFormat('%b %d'));
        const yAxis = d3.axisLeft(yScale).ticks(8);
        const xGrid = d3
          .axisBottom(xScale)
          .tickSize(-chartHeight)
          .tickFormat('');
        const yGrid = d3.axisLeft(yScale).tickSize(-chartWidth).tickFormat('');

        const xGridGroup = chart
          .append('g')
          .attr('class', 'grid x-grid')
          .attr('transform', `translate(0, ${chartHeight})`)
          .call(xGrid);
        const yGridGroup = chart
          .append('g')
          .attr('class', 'grid y-grid')
          .call(yGrid);

        const xAxisGroup = chart
          .append('g')
          .attr('class', 'axis x-axis')
          .attr('transform', `translate(0, ${chartHeight})`)
          .call(xAxis);
        const yAxisGroup = chart
          .append('g')
          .attr('class', 'axis y-axis')
          .call(yAxis);

        const line = d3
          .line()
          .x((d) => xScale(d.ctime))
          .y((d) => yScale(d.metric));

        // **FIX:** Main brush group is added BEFORE the data elements
        const mainBrush = d3
          .brushX()
          .extent([
            [0, 0],
            [chartWidth, chartHeight],
          ])
          .on('end', brushedMain);
        const mainBrushGroup = chart
          .append('g')
          .attr('class', 'brush main-brush')
          .call(mainBrush);

        const clipArea = chart
          .append('g')
          .attr('clip-path', 'url(#chart-clip)');

        const groupedData = d3.group(data, (d) => d.branch);
        const branchLines = clipArea
          .selectAll('.line')
          .data(groupedData)
          .join('path')
          .attr('class', 'line')
          .attr('fill', 'none')
          .attr('stroke', ([branch]) => colorScale(branch))
          .attr('stroke-width', 1.5)
          .attr('d', ([, v]) => line(v.sort((a, b) => a.ctime - b.ctime)));

        const branchCircles = clipArea
          .selectAll('.circle')
          .data(data)
          .join('circle')
          .attr('class', 'circle')
          .attr('cx', (d) => xScale(d.ctime))
          .attr('cy', (d) => yScale(d.metric))
          .attr('r', 2)
          .attr('fill', (d) => colorScale(d.branch));

        // --- Context Chart (Bottom) ---
        const contextHeight = 60,
          contextTop = chartHeight + 50;
        const contextGroup = svg
          .append('g')
          .attr('transform', `translate(${margin.left}, ${contextTop})`);
        const xScale2 = d3
          .scaleTime()
          .domain(fullXDomain)
          .range([0, chartWidth]);
        const yScale2 = d3
          .scaleLinear()
          .domain(yScale.domain())
          .range([contextHeight, 0]);
        const contextLine = d3
          .line()
          .x((d) => xScale2(d.ctime))
          .y((d) => yScale2(d.metric));

        contextGroup
          .selectAll('.context-line')
          .data(d3.group(dataForContext, (d) => d.branch))
          .join('path')
          .attr('class', 'context-line')
          .attr('fill', 'none')
          .attr('stroke', ([b]) => colorScale(b))
          .attr('stroke-opacity', 0.7)
          .attr('stroke-width', 1)
          .attr('d', ([, v]) =>
            contextLine(v.sort((a, b) => a.ctime - b.ctime))
          );
        contextGroup
          .append('g')
          .attr('transform', `translate(0, ${contextHeight})`)
          .call(
            d3
              .axisBottom(xScale2)
              .ticks(width / 100)
              .tickFormat(d3.timeFormat('%b %Y'))
          );

        const contextBrush = d3
          .brushX()
          .extent([
            [0, 0],
            [chartWidth, contextHeight],
          ])
          .on('end', brushedContext);
        const contextBrushGroup = contextGroup
          .append('g')
          .attr('class', 'brush')
          .call(contextBrush);

        setupTooltip(branchCircles, colorScale);

        chart.on('dblclick', resetZoom);

        // --- Brush and Zoom Functions ---
        // **FIX:** Rewritten to correctly use transitions on all elements
        function updateChartElements(transitionDuration) {
          const t = svg.transition().duration(transitionDuration);

          xAxisGroup.transition(t).call(xAxis.scale(xScale));
          yAxisGroup.transition(t).call(yAxis.scale(yScale));
          xGridGroup.transition(t).call(xGrid.scale(xScale));
          yGridGroup.transition(t).call(yGrid.scale(yScale));

          branchLines.transition(t).attr('d', ([, v]) => line(v));
          branchCircles
            .transition(t)
            .attr('cx', (d) => xScale(d.ctime))
            .attr('cy', (d) => yScale(d.metric));
        }

        function brushedContext(event) {
          if (!event.selection) return;
          const [x0, x1] = event.selection.map(xScale2.invert);
          xScale.domain([x0, x1]);
          updateChartElements(400);
          mainBrushGroup.call(mainBrush.move, null);
        }

        function brushedMain(event) {
          if (!event.selection) return;
          const [x0, x1] = event.selection.map(xScale.invert);
          xScale.domain([x0, x1]);
          mainBrushGroup.call(mainBrush.move, null);
          updateChartElements(400);
          contextBrushGroup.call(
            contextBrush.move,
            xScale.domain().map(xScale2)
          );
        }

        function resetZoom() {
          xScale.domain(fullXDomain);
          yScale.domain(fullYDomain);
          updateChartElements(500);
          contextBrushGroup.call(contextBrush.move, null);
        }
      }

      function setupTooltip(circles, colorScale) {
        let tTimeout;
        const tooltip = DOMElements.tooltip;
        circles
          .on('mouseover', function (event, d) {
            clearTimeout(tTimeout);
            const [ptrX, ptrY] = d3.pointer(event, document.body);

            tooltip
              .style('opacity', 1)
              .style('left', `${ptrX}px`)
              .style('top', `${ptrY}px`)
              .html(
                `<div class="tooltip-date">${d3.timeFormat('%A, %B %d, %Y')(
                  d.ctime
                )}</div><div class="version-item"><span class="version-color" style="background-color:${colorScale(
                  d.branch
                )}"></span><span class="version-name">${
                  d.branch
                }</span><span class="version-value">${d.metric.toFixed(
                  2
                )}</span></div><div class="commit-details"><strong>Revision:</strong> ${d.revision.substring(
                  0,
                  10
                )}...<br><a href="https://github.com/postgres/postgres/commit/${
                  d.revision
                }" target="_blank">View on GitHub</a></div>`
              );
          })
          .on('mouseout', () => {
            tTimeout = setTimeout(() => {
              tooltip.style('opacity', 0);
            }, 250);
          });

        tooltip
          .on('mouseover', () => clearTimeout(tTimeout))
          .on('mouseout', () => {
            tTimeout = setTimeout(() => {
              tooltip.style('opacity', 0);
            }, 250);
          });
      }

      function renderLegend(branches, colorScale) {
        const { legendContainer } = DOMElements;
        legendContainer
          .selectAll('.legend-item')
          .data(branches, (d) => d)
          .join(
            (enter) => {
              const item = enter
                .append('div')
                .attr('class', 'legend-item')
                .attr('data-branch', (d) => d);
              item.html((d) => `${BRANCH_ICON_SVG}<span>${d}</span>`);
              item.select('svg path').attr('fill', (d) => colorScale(d));
              item.on('click', (event, d) => {
                const checkbox = DOMElements.branchListContainer.querySelector(
                  `input[value="${d}"]`
                );
                if (checkbox) {
                  checkbox.checked = !checkbox.checked;
                  checkbox.dispatchEvent(
                    new Event('change', { bubbles: true })
                  );
                }
              });
              return item;
            },
            (update) => update,
            (exit) => exit.remove()
          )
          .classed('inactive', (d) => !currentFilters.branches.includes(d));
      }

      function updateActiveFiltersDisplay() {
        const scaleText = `Scale Factor: ${currentFilters.scale}`;
        const branchesText =
          currentFilters.branches.length > 0
            ? `${currentFilters.branches.length} branches selected`
            : 'No branches selected';
        DOMElements.activeFiltersDisplay.textContent = `${scaleText} | ${branchesText}`;
      }

      function updateLastUpdated(data) {
        if (!data || data.length === 0) return;
        const maxDate = d3.max(data, (d) => d.ctime);
        DOMElements.lastUpdated.textContent = `Most Recent Test: ${d3.timeFormat(
          '%Y-%m-%d'
        )(maxDate)}`;
      }

      // --- UTILITY ---
      function parseCSV(csvText) {
        const lines = csvText.trim().split('\n');
        if (lines.length < 2) return [];
        const headers = lines[0].split(',').map((h) => h.trim());
        return lines.slice(1).map((line) => {
          const values = line.split(',');
          return headers.reduce((obj, header, i) => {
            obj[header] = values[i] ? values[i].trim() : '';
            return obj;
          }, {});
        });
      }
      function handleError(error) {
        console.error('Error:', error);
        DOMElements.svg.selectAll('*').remove();
        DOMElements.svg
          .append('text')
          .attr('x', '50%')
          .attr('y', '50%')
          .attr('text-anchor', 'middle')
          .attr('fill', 'red')
          .text(`Error: ${error.message}`);
      }
    </script>
  </body>
</html>
